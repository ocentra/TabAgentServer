# Indexing Crate Test Report
**Generated**: 2025-11-05 17:26:09
**Mode**: 
**Total Tests**: 104
**Passed**: 0
**Failed**: 20

## Test Output
```
   Compiling indexing v0.1.0 (E:\Desktop\TabAgent\TabAgentServer\Rust\indexing) warning: unexpected `cfg` condition value: `std`    --> indexing\src\visit\mod.rs:451:7     | 451 | #[cfg(feature = "std")]     |       ^^^^^^^^^^^^^^^     |     = note: expected values for `feature` are: `simd`     = help: consider adding `std` as a feature in `Cargo.toml`     = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration     = note: `#[warn(unexpected_cfgs)]` on by default System.Management.Automation.RemoteException warning: use of deprecated method `crossbeam::crossbeam_epoch::Atomic::<T>::compare_and_set_weak`: Use `compare_exchange_weak` instead    --> indexing\src\lock_free\lock_free_btree.rs:165:29     | 165 |             match self.root.compare_and_set_weak(     |                             ^^^^^^^^^^^^^^^^^^^^     |     = note: `#[warn(deprecated)]` on by default System.Management.Automation.RemoteException warning: unused variable: `parent_ref`    --> indexing\src\lock_free\lock_free_btree.rs:304:13     | 304 |         let parent_ref = unsafe { parent_ptr.as_ref() }.unwrap();     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_parent_ref`     |     = note: `#[warn(unused_variables)]` on by default System.Management.Automation.RemoteException warning: unused variable: `new_child_ref`    --> indexing\src\lock_free\lock_free_btree.rs:318:13     | 318 |         let new_child_ref = unsafe { new_child_ptr.as_ref() }.unwrap();     |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_child_ref` System.Management.Automation.RemoteException warning: unused variable: `key`    --> indexing\src\lock_free\lock_free_btree.rs:420:26     | 420 |     pub fn remove(&self, key: &K) -> DbResult<Option<V>> {     |                          ^^^ help: if this is intentional, prefix it with an underscore: `_key` System.Management.Automation.RemoteException warning: unused variable: `key`    --> indexing\src\lock_free\lock_free_skiplist.rs:121:26     | 121 |     pub fn insert(&self, key: K, value: V) -> DbResult<Option<V>> {     |                          ^^^ help: if this is intentional, prefix it with an underscore: `_key` System.Management.Automation.RemoteException warning: unused variable: `value`    --> indexing\src\lock_free\lock_free_skiplist.rs:121:34     | 121 |     pub fn insert(&self, key: K, value: V) -> DbResult<Option<V>> {     |                                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_value` System.Management.Automation.RemoteException warning: unused variable: `key`    --> indexing\src\lock_free\lock_free_skiplist.rs:127:23     | 127 |     pub fn get(&self, key: &K) -> DbResult<Option<V>> {     |                       ^^^ help: if this is intentional, prefix it with an underscore: `_key` System.Management.Automation.RemoteException warning: unused variable: `key`    --> indexing\src\lock_free\lock_free_skiplist.rs:135:26     | 135 |     pub fn remove(&self, key: &K) -> DbResult<Option<V>> {     |                          ^^^ help: if this is intentional, prefix it with an underscore: `_key` System.Management.Automation.RemoteException warning: unused variable: `thread_id`    --> indexing\src\lock_free\lock_free_benchmark.rs:157:13     | 157 |         for thread_id in 0..NUM_THREADS {     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_thread_id` System.Management.Automation.RemoteException warning: unused variable: `thread_id`    --> indexing\src\lock_free\lock_free_benchmark.rs:194:13     | 194 |         for thread_id in 0..NUM_THREADS {     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_thread_id` System.Management.Automation.RemoteException warning: unused variable: `edge_id`    --> indexing\src\advanced\optimized_graph.rs:475:30     | 475 |     fn edge_endpoints(&self, edge_id: Self::EdgeId) -> Option<(Self::NodeId, Self::NodeId)> {     |                              ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_edge_id` System.Management.Automation.RemoteException warning: unused variable: `node_id`    --> indexing\src\advanced\optimized_graph.rs:504:21     | 504 |     fn edges(&self, node_id: Self::NodeId) -> DbResult<Vec<(Self::EdgeId, Self::NodeId, Self::NodeId)>> {     |                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_node_id` System.Management.Automation.RemoteException warning: unused variable: `filter`    --> indexing\src\advanced\segment.rs:156:9     | 156 |         filter: Option<&crate::payload_index::PayloadFilter>,     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_filter` System.Management.Automation.RemoteException warning: unused variable: `lat`    --> indexing\src\advanced\payload_index.rs:491:51     | 491 |                     PayloadFieldValue::GeoPoint { lat, lon } => {     |                                                   ^^^ help: try ignoring the field: `lat: _` System.Management.Automation.RemoteException warning: unused variable: `lon`    --> indexing\src\advanced\payload_index.rs:491:56     | 491 |                     PayloadFieldValue::GeoPoint { lat, lon } => {     |                                                        ^^^ help: try ignoring the field: `lon: _` System.Management.Automation.RemoteException warning: unused variable: `end`    --> indexing\src\advanced\vector_storage.rs:236:13     | 236 |         let end = start + self.dimension * 4;     |             ^^^ help: if this is intentional, prefix it with an underscore: `_end` System.Management.Automation.RemoteException warning: unused variable: `offset`    --> indexing\src\advanced\vector_storage.rs:272:22     | 272 |         if let Some(&offset) = self.id_to_offset.get(id) {     |                      ^^^^^^ help: if this is intentional, prefix it with an underscore: `_offset` System.Management.Automation.RemoteException warning: unused variable: `id`    --> indexing\src\advanced\vector_storage.rs:281:34     | 281 |     fn get_vector_mut(&mut self, id: &EmbeddingId) -> DbResult<Option<&mut Vec<f32>>> {     |                                  ^^ help: if this is intentional, prefix it with an underscore: `_id` System.Management.Automation.RemoteException warning: unused variable: `chunk_id`    --> indexing\src\advanced\vector_storage.rs:487:22     | 487 |         if let Some((chunk_id, index_in_chunk)) = self.id_to_location.remove(id) {     |                      ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_chunk_id` System.Management.Automation.RemoteException warning: unused variable: `index_in_chunk`    --> indexing\src\advanced\vector_storage.rs:487:32     | 487 |         if let Some((chunk_id, index_in_chunk)) = self.id_to_location.remove(id) {     |                                ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_index_in_chunk` System.Management.Automation.RemoteException warning: unused variable: `serialized`   --> indexing\src\advanced\persistence.rs:82:13    | 82 |         let serialized = rkyv::from_bytes::<SerializedVectorIndex, rkyv::rancor::Error>(&buffer)    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_serialized` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:263:40     | 263 |     pub fn must_match_string(mut self, field: &str, value: &str) -> Self {     |                                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:271:41     | 271 |     pub fn must_match_integer(mut self, field: &str, value: i64) -> Self {     |                                         ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:279:41     | 279 |     pub fn must_match_boolean(mut self, field: &str, value: bool) -> Self {     |                                         ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:287:33     | 287 |     pub fn must_range(mut self, field: &str, from: Option<f64>, to: Option<f64>) -> Self {     |                                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:295:42     | 295 |     pub fn should_match_string(mut self, field: &str, value: &str) -> Self {     |                                          ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:303:44     | 303 |     pub fn must_not_match_string(mut self, field: &str, value: &str) -> Self {     |                                            ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:341:19     | 341 |     fn bfs(&self, start: Self::NodeId) -> DbResult<Bfs<Self>>     |                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:349:27     | 349 |     fn bfs_collect(&self, start: Self::NodeId) -> DbResult<Vec<Self::NodeId>> {     |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:362:19     | 362 |     fn dfs(&self, start: Self::NodeId) -> DbResult<Dfs<Self>>     |                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:370:27     | 370 |     fn dfs_collect(&self, start: Self::NodeId) -> DbResult<Vec<Self::NodeId>> {     |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:375:30     | 375 |     fn dfs_post_order(&self, start: Self::NodeId) -> DbResult<DfsPostOrder<Self>>     |                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:383:38     | 383 |     fn dfs_post_order_collect(&self, start: Self::NodeId) -> DbResult<Vec<Self::NodeId>> {     |                                      ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `hot_graph`     --> indexing\src\lib.rs:1822:21      | 1822 |         if let Some(hot_graph) = &self.hot_graph {      |                     ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hot_graph` System.Management.Automation.RemoteException warning: unused variable: `hot_graph`     --> indexing\src\lib.rs:1842:21      | 1842 |         if let Some(hot_graph) = &self.hot_graph {      |                     ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hot_graph` System.Management.Automation.RemoteException warning: field `persist_path` is never read   --> indexing\src\core\vector.rs:92:5    | 72 | pub struct VectorIndex {    |            ----------- field in this struct ... 92 |     persist_path: PathBuf,    |     ^^^^^^^^^^^^    |    = note: `#[warn(dead_code)]` on by default System.Management.Automation.RemoteException warning: field `last_access` is never read  --> indexing\src\lock_free\lock_free_common.rs:8:5   | 6 | pub struct LockFreeAccessTracker {   |            --------------------- field in this struct 7 |     access_count: AtomicUsize, 8 |     last_access: AtomicUsize,   |     ^^^^^^^^^^^   |   = note: `LockFreeAccessTracker` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis System.Management.Automation.RemoteException warning: fields `path_cache` and `centrality_cache` are never read   --> indexing\src\lock_free\lock_free_hot_graph.rs:78:5    | 58 | pub struct LockFreeHotGraphIndex {    |            --------------------- fields in this struct ... 78 |     path_cache: Arc<DashMap<(String, String), Option<Vec<String>>>>,    |     ^^^^^^^^^^ ... 81 |     centrality_cache: Arc<DashMap<String, f32>>,    |     ^^^^^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: field `next` is never read   --> indexing\src\lock_free\lock_free_btree.rs:34:5    | 17 | struct Node<K, V> {    |        ---- field in this struct ... 34 |     next: Atomic<Node<K, V>>,    |     ^^^^ System.Management.Automation.RemoteException warning: method `is_minimal` is never used   --> indexing\src\lock_free\lock_free_btree.rs:72:8    | 37 | / impl<K, V> Node<K, V> 38 | | where 39 | |     K: Ord + Clone, 40 | |     V: Clone,    | |_____________- method in this implementation ... 72 |       fn is_minimal(&self, degree: usize) -> bool {    |          ^^^^^^^^^^ System.Management.Automation.RemoteException warning: constant `PROBABILITY` is never used   --> indexing\src\lock_free\lock_free_skiplist.rs:16:7    | 16 | const PROBABILITY: f64 = 0.5;    |       ^^^^^^^^^^^ System.Management.Automation.RemoteException warning: fields `key`, `value`, `forward`, `level`, and `ref_count` are never read   --> indexing\src\lock_free\lock_free_skiplist.rs:21:5    | 19 | struct SkipListNode<K, V> {    |        ------------ fields in this struct 20 |     /// The key 21 |     key: K,    |     ^^^ ... 24 |     value: V,    |     ^^^^^ ... 27 |     forward: Vec<Atomic<SkipListNode<K, V>>>,    |     ^^^^^^^ ... 30 |     level: usize,    |     ^^^^^ ... 33 |     ref_count: AtomicU32,    |     ^^^^^^^^^ System.Management.Automation.RemoteException warning: methods `acquire` and `release` are never used   --> indexing\src\lock_free\lock_free_skiplist.rs:58:8    | 36 | / impl<K, V> SkipListNode<K, V> 37 | | where 38 | |     K: Ord + Clone, 39 | |     V: Clone,    | |_____________- methods in this implementation ... 58 |       fn acquire(&self) {    |          ^^^^^^^ ... 63 |       fn release(&self) -> bool {    |          ^^^^^^^ System.Management.Automation.RemoteException warning: field `max_level` is never read   --> indexing\src\lock_free\lock_free_skiplist.rs:77:5    | 72 | pub struct LockFreeSkipList<K, V> {    |            ---------------- field in this struct ... 77 |     max_level: AtomicUsize,    |     ^^^^^^^^^ System.Management.Automation.RemoteException warning: method `random_level` is never used    --> indexing\src\lock_free\lock_free_skiplist.rs:104:8     |  83 | / impl<K, V> LockFreeSkipList<K, V>  84 | | where  85 | |     K: Ord + Clone,  86 | |     V: Clone,     | |_____________- method in this implementation ... 104 |       fn random_level(&self) -> usize {     |          ^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: methods `acquire_vec_string` and `release_vec_string` are never used     --> indexing\src\advanced\hybrid.rs:1408:8      |  451 | impl HotGraphIndex {      | ------------------ methods in this implementation ... 1408 |     fn acquire_vec_string(&mut self) -> Vec<String> {      |        ^^^^^^^^^^^^^^^^^^ ... 1413 |     fn release_vec_string(&mut self, mut vec: Vec<String>) {      |        ^^^^^^^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: fields `path_cache` and `centrality_cache` are never read    --> indexing\src\advanced\optimized_graph.rs:125:5     |  96 | pub struct OptimizedGraphIndex {     |            ------------------- fields in this struct ... 125 |     path_cache: HashMap<(NodeIndex, NodeIndex), Option<Vec<NodeIndex>>>,     |     ^^^^^^^^^^ ... 128 |     centrality_cache: HashMap<NodeIndex, f32>,     |     ^^^^^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: field `path` is never read   --> indexing\src\advanced\segment.rs:32:5    | 27 | pub struct Segment {    |            ------- field in this struct ... 32 |     path: PathBuf,    |     ^^^^ System.Management.Automation.RemoteException warning: field `distance_metric` is never read    --> indexing\src\advanced\segment.rs:430:5     | 425 | pub struct SegmentBasedVectorIndex {     |            ----------------------- field in this struct ... 430 |     distance_metric: Box<dyn DistanceMetric>,     |     ^^^^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: field `file_path` is never read    --> indexing\src\advanced\vector_storage.rs:114:5     | 112 | pub struct MmapVectorStorage {     |            ----------------- field in this struct 113 |     /// Path to the storage file 114 |     file_path: PathBuf,     |     ^^^^^^^^^ System.Management.Automation.RemoteException warning: method `load_chunk` is never used    --> indexing\src\advanced\vector_storage.rs:416:8     | 368 | impl ChunkedVectorStorage {     | ------------------------- method in this implementation ... 416 |     fn load_chunk(&self, chunk_id: usize) -> DbResult<Chunk> {     |        ^^^^^^^^^^ System.Management.Automation.RemoteException warning: field `distance_metric` is never read    --> indexing\src\advanced\persistence.rs:347:5     | 342 | pub struct EnhancedVectorIndex {     |            ------------------- field in this struct ... 347 |     distance_metric: Box<dyn DistanceMetric>,     |     ^^^^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: field `graph` is never read    --> indexing\src\utils\iterators.rs:220:5     | 218 | pub struct EdgeIterator<G: GraphBase> {     |            ------------ field in this struct 219 |     /// The graph being traversed 220 |     graph: G,     |     ^^^^^ System.Management.Automation.RemoteException warning: constant `Outgoing` should have an upper case name    --> indexing\src\algorithms\graph_traits.rs:139:11     | 139 | pub const Outgoing: Direction = Direction::Outgoing;     |           ^^^^^^^^ help: convert the identifier to upper case: `OUTGOING`     |     = note: `#[warn(non_upper_case_globals)]` on by default System.Management.Automation.RemoteException warning: constant `Incoming` should have an upper case name    --> indexing\src\algorithms\graph_traits.rs:142:11     | 142 | pub const Incoming: Direction = Direction::Incoming;     |           ^^^^^^^^ help: convert the identifier to upper case: `INCOMING` System.Management.Automation.RemoteException warning: `indexing` (lib) generated 56 warnings     Finished `test` profile [unoptimized + debuginfo] target(s) in 5.08s      Running tests\mod.rs (target\debug\deps\mod-d87d95079f28f61f.exe)  running 104 tests NEGATIVE TEST: Attempting to open same database twice (should fail)   First open...  ≡ƒöä TEST: Verify both outgoing AND incoming indexes updated atomically  ≡ƒò╕∩╕Å  TEST: Add edges and retrieve incoming edges with zero-copy  ≡ƒò╕∩╕Å  TEST: Add edges and retrieve outgoing edges with zero-copy  ≡ƒÆ╛ TEST: Graph index caching consistency ΓÖ╗∩╕Å  Reusing existing mock vectors database  ≡ƒöì TEST: Vector search caching consistency  ≡ƒùæ∩╕Å  TEST: Remove edge and verify it's gone from both directions  ΓÜí TEST: Structural index query performance (100 items)  ≡ƒÆ¼ TEST: Index Chat node across all indexes  ≡ƒôè TEST: Vector metadata (timestamp, dimension)  ≡ƒÄ¿ TEST: Index embedding in vector index  Γ£ë∩╕Å  TEST: Index Message node across all indexes  ≡ƒùé∩╕Å  TEST: Add property indexes and retrieve with zero-copy (NEW ARCHITECTURE)  ≡ƒöó TEST: Zero-copy edge counting (O(1) performance)  ≡ƒöì TEST: Add 3D vectors and search with HNSW  ≡ƒöù TEST: Index edge in graph index  ≡ƒîÉ TEST: High-dimensional vectors (384D like real embeddings)  ≡ƒùæ∩╕Å  TEST: Remove vector from HNSW index    ≡ƒô¥ Adding 3 vectors (3D)...    ≡ƒô¥ Adding vector with metadata...    ≡ƒôû Reading metadata...    Γ£à PASS: Metadata stored (timestamp=1762381566886, dim=3)    ≡ƒöÄ First search...    ≡ƒöÄ Second search (consistency check)...    Γ£à PASS: Search results consistent    ≡ƒô¥ Adding 3 vectors (3D)...    ≡ƒöÄ Searching for nearest neighbors...    Γ£à PASS: Found 2 nearest neighbors    ≡ƒô¥ Creating 384-dimensional vectors...    ≡ƒô¥ Adding vector v1...    ≡ƒô¥ Adding 3 high-dimensional vectors...    ≡ƒùæ∩╕Å  Removing v1...    ≡ƒùæ∩╕Å  Removing again (should fail)...    Γ£à PASS: Vector removed successfully    ≡ƒöÄ Searching in 384D space...    Γ£à PASS: HNSW works with 384-dimensional vectors   Second open (same file, should fail with locking error)... ΓÖ╗∩╕Å  Reusing existing mock vectors database test integration::vector_tests::test_metadata ... ok test integration::caching_tests::test_vector_index_search_caching ... ok test integration::vector_tests::test_add_and_search ... ok   TEST PASSED: Got expected locking error: Invalid operation: mdbx_env_open failed: -30778 NEGATIVE TEST COMPLETE: File locking protection prevents duplicate opens test integration::vector_tests::test_remove ... ok test integration::vector_tests::test_realistic_dimensions ... ok  ≡ƒôè TEST: Access pattern tracking for tier management  ≡ƒöÑ TEST: Hot graph index basic operations    ≡ƒô¥ Adding node...    ≡ƒô¥ Adding 2 nodes... test fixtures::tests::test_mock_vectors_db_reusable ... ok    ≡ƒôû Checking initial temperature...    ≡ƒô¥ Adding edge...    ≡ƒô¥ Adding vector to hot tier...    ≡ƒôû Checking neighbors...    ≡ƒùæ∩╕Å  Removing edge...    Γ£à PASS: Both graph and vector track temperature correctly    Γ£à PASS: Hot graph add/remove works  ≡ƒöÑ TEST: Hot vector index basic operations    ≡ƒô¥ Adding 3 vectors to hot tier...    ≡ƒöÄ Searching hot tier...    Γ£à PASS: Hot vector search works (similarity=1.00) test unit::advanced::hybrid_tests::test_access_tracking ... ok test unit::advanced::hybrid_tests::test_hot_graph_index_basic_operations ... ok  ≡ƒöó TEST: Quantized vector compression    ≡ƒô¥ Quantizing vector...    ≡ƒôû Reconstructing vector... test unit::advanced::hybrid_tests::test_hot_vector_index_basic_operations ... ok    Γ£à PASS: Quantization loss < 1%  ≡ƒôÉ TEST: Quantized vector cosine similarity    ≡ƒöÄ Computing similarities...    Γ£à PASS: Similar=0.99, Orthogonal=0.00 test unit::advanced::hybrid_tests::test_quantized_vector_basic ... ok    ≡ƒô¥ Adding edge... test unit::advanced::hybrid_tests::test_quantized_vector_cosine_similarity ... ok  ≡ƒù║∩╕Å  TEST: Memory-map multiple vectors  ≡ƒÆ╛ TEST: Memory-map persistence across instances    ≡ƒô¥ Adding 2 edges...  ≡ƒù║∩╕Å  TEST: Memory-mapped vector write/read    ≡ƒùæ∩╕Å  Removing edge...    ≡ƒô¥ Adding 2 edges to msg_1...    Γ£à PASS: Edge removed from both directions    ≡ƒô¥ Indexing chat node...    ≡ƒô¥ Indexing edge...    ≡ƒöó Counting edges (ZERO-COPY O(1))...    Γ£à PASS: Counted 2 outgoing, 1 incoming    ≡ƒô¥ Adding 3 messages to 2 chats...    ≡ƒôû Querying by node_type (ZERO-COPY)...    ≡ƒôû Reading incoming edges (ZERO-COPY)...    ≡ƒôû Querying outgoing edges (ZERO-COPY)...    ≡ƒôû Querying by topic (ZERO-COPY)...    Γ£à PASS: Retrieved 2 incoming edges    Γ£à PASS: Chat indexed across all properties    Γ£à PASS: Edge indexed in graph    ≡ƒô¥ Indexing 384D embedding...    ≡ƒô¥ Adding 100 messages to chat_123...    ≡ƒöÄ Searching for similar vectors...    Γ£à PASS: Found 1 similar vectors    ≡ƒôû Reading chat_123 messages (ZERO-COPY)...    ≡ƒôû Reading chat_456 messages (ZERO-COPY)...    Γ£à PASS: Retrieved 2 + 1 nodes with zero-copy    ≡ƒô¥ Adding edge: chat_1 -> msg_1 test fixtures::tests::test_create_temp_db ... ok    ≡ƒôû Checking outgoing from chat_1...    ≡ƒôû Checking incoming to msg_1...    Γ£à PASS: Bidirectional index works atomically test integration::structural_tests::test_to_owned_when_needed ... ok  ≡ƒöÇ TEST: Hybrid vector index with payload filtering  ≡ƒôª TEST: Create payload with mixed field types    ≡ƒô¥ Adding string, integer, boolean fields...    Γ£à PASS: Payload created with 3 fields test unit::advanced::payload_index_tests::test_payload_creation ... ok    ≡ƒô¥ Indexing message node...  ≡ƒöì TEST: Filter vectors by payload metadata    ≡ƒô¥ Adding 2 vectors with payloads...    ≡ƒöì Filtering by category=A...    Γ£à PASS: Filtered 1 vectors by payload test unit::advanced::payload_index_tests::test_payload_index ... ok    ≡ƒôû Querying by chat_id (ZERO-COPY)...  ≡ƒîƒ TEST: Enhanced vector index with persistence    Γ£à PASS: Message indexed and retrieved    Γ£ì∩╕Å  Writing vector (first mmap instance)... test integration::graph_tests::test_remove_edge ... ok test integration::structural_tests::test_count_zero_copy ... ok  ≡ƒÆ╛ TEST: Persistent segment index save/load  ≡ƒÆ╛ TEST: Persistent vector index save/load    ≡ƒô¥ Adding 2 edges...    ≡ƒô¥ Adding 2 edges from chat_1...    ≡ƒô¥ Creating mmap storage (4D)... Γ£à PROOF: Cache hit ratio exceeds 80% target    Hit ratio: 89.00%    Warm hits: 89    Cold hits: 11    ≡ƒô¥ Creating mmap storage (3D)...    ≡ƒôû First read from MDBX...    ≡ƒôû Second read (tests consistency)...    Γ£à PASS: Consistent reads from cache    ≡ƒÆ╛ Dropping storage (should flush to disk)...    ≡ƒôû Reading outgoing edges (ZERO-COPY)...    Γ£à PASS: Retrieved 2 edges with zero-copy    ≡ƒôû Reading vector (new mmap instance)... Γ£à PROOF: 1 allocation saved 99 MDBX transactions    Cold hits (MDBX): 1    Warm hits (cache): 99    Γ£ì∩╕Å  Writing 3 vectors... test integration::graph_tests::test_count_zero_copy ... ok    ≡ƒôû Reading all 3 vectors (ZERO-COPY)...    Γ£à PASS: 3 vectors stored at different offsets test integration::graph_tests::test_add_and_get_incoming_zero_copy ... ok    ≡ƒô¥ Creating hybrid index...  ≡ƒôè TEST: Add and remove vectors from segment test integration::index_manager_tests::test_index_embedding ... ok  ≡ƒöì TEST: Segment-based vector index search test integration::warm_cache_validation::test_hot_node_cache_hit_ratio ... ok test integration::index_manager_tests::test_index_chat_node_zero_copy ... ok  ≡ƒôè TEST: Create vector segment test integration::index_manager_tests::test_index_edge_zero_copy ... ok  ≡ƒôÜ TEST: Segment manager auto-creates segments    Γ£à PASS: Data persists across mmap instances  ≡ƒôª TEST: Chunked vector storage  ≡ƒùä∩╕Å  TEST: In-memory vector storage    ≡ƒô¥ Adding vector...    ≡ƒôû Retrieving vector...    ≡ƒùæ∩╕Å  Removing vector...    Γ£à PASS: In-memory storage works    ≡ƒô¥ Creating persistent segment index... test unit::advanced::vector_storage_tests::test_in_memory_storage ... ok    ≡ƒô¥ Creating enhanced vector index...  ≡ƒù║∩╕Å  TEST: Memory-mapped vector storage    Γ£ì∩╕Å  Writing vector to mmap...    ≡ƒôû Reading vector from mmap (ZERO-COPY)...    Γ£à PASS: Vector written and read via mmap test integration::warm_cache_validation::test_warm_cache_saves_cold_transactions ... ok    ≡ƒô¥ Adding 2 vectors... test integration::structural_tests::test_add_and_get_zero_copy ... ok test unit::lock_free::benchmark_tests::test_benchmark_hot_vector_index_search ... ignored, Long-running benchmark test - run with --ignored    ≡ƒô¥ Creating persistent index...  ΓÜí TEST: Benchmark hot vector index performance    ≡ƒöº Running benchmark... test unit::lock_free::benchmark_tests::test_benchmark_mixed_workload ... ignored, Long-running benchmark test - run with --ignored  ΓÜí TEST: Benchmark result calculations    Γ£à PASS: 20000 ops/sec calculated correctly test unit::lock_free::benchmark_tests::test_benchmark_result_creation ... ok    ≡ƒô¥ Adding 2 vectors...    ≡ƒô¥ Adding vector with payload... test unit::advanced::memory_mapping_tests::test_mmap_multiple_vectors ...  ≡ƒî│ TEST: Lock-free B-tree basic operations ok    ≡ƒô¥ Insert 1=one...    ≡ƒöä Update 1=updated... test integration::graph_tests::test_bidirectional_index ...  ≡ƒî│ TEST: Lock-free B-tree concurrent inserts    ≡ƒô¥ Insert 2, 3...    ≡ƒº╡ Spawning 100 threads... ok    Γ£à PASS: B-tree contains 3 items test unit::lock_free::btree_tests::test_lock_free_btree_basic ... ok  ≡ƒôè TEST: Lock-free access tracker    ≡ƒô¥ Recording access...    Γ£à PASS: Access tracked (count=1)    ≡ƒöÄ Searching with filter...    Γ£à PASS: Hybrid index works with payloads  ≡ƒôê TEST: Lock-free statistics tracking    ≡ƒô¥ Recording stats...    Γ£à PASS: Stats tracked (queries=1, vectors=1)    ≡ƒô¥ Creating segment with capacity 1000...    ≡ƒô¥ Creating mmap storage...    ≡ƒô¥ Creating chunked storage (10 vectors/chunk)...    ≡ƒô¥ Creating segment...    ≡ƒô¥ Creating segment-based index...    ≡ƒô¥ Creating manager with max 2 vectors per segment... System.Management.Automation.RemoteException thread 'unit::advanced::persistence_tests::test_persistent_segment_index' panicked at indexing\tests\unit\advanced\persistence_tests.rs:38:5: assertion failed: index.add_vector("vector1", vec![1.0, 0.0, 0.0]).is_ok() note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace test integration::index_manager_tests::test_index_message_node_zero_copy ... ok    ≡ƒô¥ Adding vector...    ≡ƒô¥ Adding vector... System.Management.Automation.RemoteException thread 'unit::advanced::persistence_tests::test_enhanced_vector_index' panicked at indexing\tests\unit\advanced\persistence_tests.rs:61:5: assertion failed: index.add_vector("vector1", vec![1.0, 0.0, 0.0]).is_ok()    ≡ƒô¥ Adding 2 vectors... System.Management.Automation.RemoteException thread 'unit::advanced::persistence_tests::test_persistent_vector_index' panicked at indexing\tests\unit\advanced\persistence_tests.rs:18:5: assertion failed: index.add_vector("vector1", vec![1.0, 0.0, 0.0]).is_ok()    Γ£à PASS: Segment created (id=test_segment, len=0) test unit::lock_free::hash_map_tests::test_lock_free_access_tracker ...    ≡ƒùæ∩╕Å  Removing vector...    Γ£à PASS: Chunked storage works    ≡ƒùæ∩╕Å  Removing vector...    Γ£à PASS: Mmap storage works ok    ≡ƒô¥ Adding vector... System.Management.Automation.RemoteException thread 'unit::advanced::segment_tests::test_segment_add_remove_vector' panicked at indexing\tests\unit\advanced\segment_tests.rs:43:5: assertion failed: segment.add_vector("vector1", vec![1.0, 0.0, 0.0], None).is_ok() test integration::structural_tests::test_nonexistent_property ... ok test unit::lock_free::hash_map_tests::test_lock_free_stats ... ok    ≡ƒô¥ Adding 2 vectors...    ≡ƒô¥ Adding 3 vectors (should create 2 segments)... test integration::structural_tests::test_remove ... ok System.Management.Automation.RemoteException thread 'unit::advanced::segment_tests::test_segment_manager' panicked at indexing\tests\unit\advanced\segment_tests.rs:68:5: assertion failed: manager.add_vector("vector1", vec![1.0, 0.0, 0.0], None).is_ok() System.Management.Automation.RemoteException thread 'unit::advanced::segment_tests::test_segment_based_vector_index' panicked at indexing\tests\unit\advanced\segment_tests.rs:92:5: assertion failed: index.add_vector("vector1", vec![1.0, 0.0, 0.0], None).is_ok()    ΓÅ│ Waiting for threads... test unit::advanced::memory_mapping_tests::test_mmap_persistence ... ok  ΓÜí TEST: Adaptive concurrency controller (mode switching)    ≡ƒöì Initial mode: Traditional    ≡ƒôè Simulating high load (15k ops)...    ≡ƒöä Mode after switch: Traditional  ≡ƒò╕∩╕Å  TEST: Adaptive graph index (dynamic mode) System.Management.Automation.RemoteException thread 'unit::utils::adaptive_concurrency_tests::test_adaptive_concurrency_controller' panicked at indexing\tests\unit\utils\adaptive_concurrency_tests.rs:28:5: assertion `left == right` failed   left: None  right: Some(LockFree)    ≡ƒöì Initial mode: Traditional    ≡ƒô¥ Adding node + edge...    Γ£à PASS: Adaptive graph index works  ≡ƒò╕∩╕Å  TEST: Lock-free hot graph index basic operations    ≡ƒô¥ Adding node...    ≡ƒô¥ Adding edge...    ≡ƒôû Getting neighbors...    Γ£à PASS: Graph has 2 nodes  ≡ƒöÑ TEST: Lock-free hot vector index basic operations  ≡ƒò╕∩╕Å  TEST: Lock-free hot graph index concurrent adds    ≡ƒô¥ Adding vector...    ≡ƒùæ∩╕Å  Removing vector...    Γ£à PASS: Add/remove works    ≡ƒº╡ Spawning 10 threads...    ΓÅ│ Waiting for threads... test integration::caching_tests::test_graph_index_caching_behavior ... ok test integration::structural_tests::test_duplicate_add ... ok test integration::graph_tests::test_add_and_get_outgoing_zero_copy ... ok  ≡ƒôª TEST: Graph batch processor (bulk nodes/edges)  ≡ƒöÑ TEST: Lock-free hot vector index concurrent adds    ≡ƒô¥ Batch adding 2 nodes...    ≡ƒº╡ Spawning 10 threads...    ≡ƒô¥ Batch adding 2 edges...    ≡ƒùæ∩╕Å  Batch removing 2 edges...    ≡ƒùæ∩╕Å  Batch removing 2 nodes...    Γ£à PASS: Batch graph operations work (2 nodes, 2 edges) test unit::advanced::memory_mapping_tests::test_mmap_vector_storage_write_and_read ... ok test unit::advanced::payload_index_tests::test_hybrid_vector_index ... ok test unit::advanced::persistence_tests::test_persistent_segment_index ... FAILED test unit::advanced::persistence_tests::test_persistent_vector_index ... FAILED  ≡ƒÅù∩╕Å  TEST: GraphIndexBuilder (graph configuration)    ≡ƒô¥ Building graph index builder (hybrid mode)...    Γ£à PASS: GraphIndexBuilder construction works test unit::advanced::vector_storage_tests::test_chunked_storage ... ok test unit::advanced::vector_storage_tests::test_mmap_storage ... ok test unit::advanced::persistence_tests::test_enhanced_vector_index ... FAILED  ≡ƒÅù∩╕Å  TEST: SearchQueryBuilder (query configuration)    ≡ƒô¥ Building search query (limit=5, payload=true)...    Γ£à PASS: SearchQueryBuilder works test unit::advanced::segment_tests::test_segment_creation ...  ≡ƒÅù∩╕Å  TEST: SegmentIndexBuilder (multi-segment index) ok    ΓÅ│ Waiting for threads... test unit::utils::adaptive_concurrency_tests::test_adaptive_concurrency_controller ... FAILED  ≡ƒôè TEST: Cache statistics tracking    ≡ƒô¥ Performing cache operations...    ≡ƒôè Checking statistics...    Γ£à PASS: Stats tracked (hits=2, misses=1, ratio=67%)    ≡ƒô¥ Building with segment params (5k/segment)...  ≡ƒöì TEST: Adaptive vector index (dynamic mode)    ≡ƒöì Initial mode: Traditional    ≡ƒô¥ Adding vector...    ≡ƒöì Searching...  ≡ƒôª TEST: Combined batch processor (vectors + graph)    Γ£à PASS: Adaptive vector index works (len=1)    ≡ƒô¥ Batch processing vectors + graph ops...    Γ£à PASS: SegmentIndexBuilder works    Γ£à PASS: Combined batch works (2 vectors, 2 nodes)  ≡ƒôª TEST: Vector batch processor (bulk add/remove) test unit::utils::adaptive_concurrency_tests::test_adaptive_graph_index ... ok    ≡ƒô¥ Batch adding 2 vectors...    ≡ƒùæ∩╕Å  Batch removing 2 vectors... test unit::advanced::segment_tests::test_segment_add_remove_vector ... FAILED   Γ£à PASS: Batch add/remove works (2 vectors)  ≡ƒÅù∩╕Å  TEST: EnhancedIndexBuilder (advanced features)   ≡ƒÅù∩╕Å  TEST: PayloadBuilder (multi-field metadata)    ≡ƒô¥ Building payload with 3 fields... test unit::lock_free::hot_graph_tests::test_lock_free_hot_graph_index_basic ... ok    Γ£à PASS: PayloadBuilder works (3 fields) test unit::advanced::segment_tests::test_segment_based_vector_index ... FAILED    ≡ƒô¥ Building enhanced index with auto-optimize...  ≡ƒöì TEST: Vector search result caching    ≡ƒô¥ Caching search results...    ≡ƒô¥ Caching metadata...    Γ£à PASS: Vector search cache stores results + metadata  ≡ƒÅù∩╕Å  TEST: VectorIndexBuilder (fluent construction)    Γ£à PASS: EnhancedIndexBuilder works  ≡ƒò╕∩╕Å  TEST: Graph traversal result caching    ≡ƒô¥ Caching BFS results...    ≡ƒô¥ Caching shortest path results...    Γ£à PASS: Graph traversal cache stores BFS + paths test unit::advanced::segment_tests::test_segment_manager ... FAILED    ≡ƒô¥ Building with custom params (M=32, efC=100)...  ≡ƒÆ╛ TEST: LRU cache eviction policy    ≡ƒô¥ Adding key1, key2 (capacity=2)...    ≡ƒô¥ Adding key3 (should evict LRU)...  ≡ƒÆ╛ TEST: Multi-level cache (primary + secondary)    ≡ƒô¥ Adding 3 values...    ≡ƒùæ∩╕Å  Removing key2...  ≡ƒÅù∩╕Å  TEST: PayloadFilterBuilder (must/should/must_not)    ≡ƒô¥ Building filter (2 must, 1 should, 1 must_not)...    Γ£à PASS: PayloadFilterBuilder works    Γ£à PASS: LRU eviction works correctly    ≡ƒô¥ Adding key4, key5 (triggers eviction)...    ≡ƒôè Checking stats...    Γ£à PASS: Multi-level cache works (4 accesses) test unit::lock_free::hot_vector_tests::test_lock_free_hot_vector_index_basic ... ok  ΓÜÖ∩╕Å  TEST: Warm graph cache configuration defaults    Γ£à PASS: Default config (edges=5000, nodes=10000, TTL=1800s)    ≡ƒôû Verifying all inserts...    Γ£à PASS: 10 concurrent vector adds successful    Γ£à PASS: 10 concurrent node adds successful System.Management.Automation.RemoteException thread 'unit::lock_free::btree_tests::test_lock_free_btree_concurrent' panicked at indexing\tests\unit\lock_free\btree_tests.rs:55:9: assertion `left == right` failed   left: None  right: Some(4) test unit::utils::batch_tests::test_graph_batch_processor ... ok    Γ£à PASS: VectorIndexBuilder works test unit::utils::builders_tests::test_graph_index_builder ... ok test unit::utils::builders_tests::test_search_query_builder ... ok  ≡ƒöü TEST: Binary conversion helpers  ΓÜÖ∩╕Å  TEST: Warm vector cache configuration defaults    Γ£à PASS: Default config (vectors=10000, searches=1000, TTL=3600s)  ΓÜí TEST: Dot product similarity metric    ≡ƒöì Testing identical vectors...  ≡ƒôÉ TEST: Cosine similarity metric    ≡ƒöì Testing identical vectors... test unit::utils::caching_tests::test_cache_stats ...    ≡ƒöì Testing orthogonal vectors...    ≡ƒöì Testing threshold binarization...    ≡ƒöì Testing opposite vectors...    Γ£à PASS: Cosine metric works (identical=1.0, orthogonal=0.0, opposite=-1.0)    ≡ƒöì Testing orthogonal vectors...    Γ£à PASS: Dot product metric works ok    Γ£à PASS: Binary conversion works (threshold=0.5) test unit::utils::adaptive_concurrency_tests::test_adaptive_vector_index ... ok test unit::utils::batch_tests::test_combined_batch_processor ... ok  ≡ƒöä TEST: Dynamic metric dispatch (runtime selection)    ≡ƒöì Testing cosine (dynamic)...  ≡ƒôÅ TEST: Euclidean distance metric    ≡ƒöì Testing identical vectors (distance=0)... test unit::utils::batch_tests::test_vector_batch_processor ...    ≡ƒöì Testing unit distance...    ≡ƒöì Testing diagonal (ΓêÜ2)...  ≡ƒöó TEST: Hamming distance (bit differences)    ≡ƒöì Testing identical binary vectors...    ≡ƒöì Testing completely different vectors...    Γ£à PASS: Euclidean metric works    ≡ƒöì Testing euclidean (dynamic)...    ≡ƒöì Testing jaccard with params (dynamic)... ok    Γ£à PASS: Dynamic dispatch works for all metrics    ≡ƒöì Testing with custom threshold...    Γ£à PASS: Hamming metric works test unit::utils::builders_tests::test_payload_builder ... ok test unit::utils::caching_tests::test_vector_search_cache ... ok  ≡ƒÄ» TEST: Jaccard similarity (set overlap)    ≡ƒöì Testing identical binary vectors... test unit::utils::builders_tests::test_segment_index_builder ...    ≡ƒöì Testing completely different vectors...    ≡ƒöì Testing with custom threshold...  ≡ƒôÜ TEST: Documentation examples compile ok  ≡ƒôì TEST: Manhattan (L1) distance metric test unit::utils::caching_tests::test_graph_traversal_cache ...    Γ£à PASS: Doc examples compile (tested in respective modules)    ≡ƒöì Testing Manhattan distance...  Γ¥î TEST: BatchError display formatting    Γ£à PASS: Jaccard metric works    Γ£à PASS: BatchError formats correctly    Γ£à PASS: Manhattan metric (L1 norm) works ok test unit::utils::builders_tests::test_payload_filter_builder ... ok test unit::utils::caching_tests::test_lru_cache ... ok  Γ¥î TEST: GraphIndexError display formatting    Γ£à PASS: GraphIndexError formats correctly  Γ¥î TEST: HybridIndexError display formatting test unit::utils::caching_tests::test_multi_level_cache ... ok  Γ¥î TEST: IndexingError display formatting    Γ£à PASS: HybridIndexError formats correctly    Γ£à PASS: IndexingError formats correctly test unit::utils::builders_tests::test_enhanced_index_builder ... ok test unit::utils::caching_tests::test_warm_graph_cache_config ... ok  Γ¥î TEST: VectorIndexError display formatting    Γ£à PASS: VectorIndexError formats correctly test unit::lock_free::hot_vector_tests::test_lock_free_hot_vector_index_concurrent ... ok Γ¥î TEST: StructuralIndexError display formatting   ΓÜí TEST: HTM counter basic operations    ≡ƒöì Initial value: 0    Γ£à PASS: HTM counter increments (0 -> 2)    Γ£à PASS: StructuralIndexError formats correctly test unit::lock_free::hot_graph_tests::test_lock_free_hot_graph_index_concurrent ... ok  ΓÜí TEST: HTM counter concurrent increments (10 threads) test unit::lock_free::btree_tests::test_lock_free_btree_concurrent ... FAILED    ≡ƒÜÇ Spawning 10 threads... test unit::utils::caching_tests::test_warm_vector_cache_config ... ok  ≡ƒöü TEST: BFS iterator (placeholder)    Γ£à PASS: Module compiles (comprehensive tests in graph_tests.rs) test unit::utils::distance_metrics_tests::test_cosine_metric ... ok    ΓÅ│ Waiting for threads to complete...  ΓÜí TEST: HTM HashMap (not yet implemented)  ≡ƒÜÇ TEST: SIMD cosine metric (vectorized)    ≡ƒöì Testing SIMD cosine (identical + orthogonal)... test unit::utils::distance_metrics_tests::test_dot_product_metric ...    ≡ƒöì Testing operations return errors (not implemented)... ok   Γ£à PASS: HTM HashMap correctly returns errors (unimplemented)    Γ£à PASS: SIMD cosine metric works  test unit::utils::distance_metrics_tests::test_binary_helpers ... ok  ≡ƒöü TEST: DFS iterator (placeholder)    Γ£à PASS: Module compiles (comprehensive tests in graph_tests.rs)  ≡ƒÜÇ TEST: SIMD dot product metric (vectorized)    ≡ƒöì Testing SIMD dot product...    Γ£à PASS: SIMD dot product metric works test unit::utils::builders_tests::test_vector_index_builder ... ok   Γ£à PASS: HTM counter correctly incremented by 10 threads (result=10)   ≡ƒÜÇ TEST: SIMD euclidean metric (vectorized)    ≡ƒöì Testing SIMD euclidean...    Γ£à PASS: SIMD euclidean metric works test unit::utils::distance_metrics_tests::test_euclidean_metric ... ok test unit::utils::distance_metrics_tests::test_dynamic_metric ... ok  ≡ƒÜÇ TEST: SIMD manhattan metric (vectorized)    ≡ƒöì Testing SIMD manhattan... test unit::utils::distance_metrics_tests::test_hamming_metric ... ok    Γ£à PASS: SIMD manhattan metric works test unit::utils::docs_tests::test_documentation_compiles ... ok test unit::utils::distance_metrics_tests::test_jaccard_metric ... ok test unit::utils::errors_tests::test_batch_error ... ok test unit::utils::distance_metrics_tests::test_manhattan_metric ... ok test unit::utils::errors_tests::test_graph_index_error ... ok test unit::utils::errors_tests::test_hybrid_index_error ... ok test unit::utils::errors_tests::test_indexing_error ... ok test unit::utils::errors_tests::test_vector_index_error ... ok test unit::utils::htm_tests::test_htm_counter_basic ... ok test unit::utils::errors_tests::test_structural_index_error ... ok test unit::utils::iterators_tests::test_bfs_iterator_placeholder ... ok test unit::utils::htm_tests::test_htm_hash_map ... ok test unit::utils::simd_distance_metrics_tests::test_simd_cosine_metric ... ok test unit::utils::iterators_tests::test_dfs_iterator_placeholder ... ok test unit::utils::simd_distance_metrics_tests::test_simd_dot_product_metric ... ok test unit::utils::htm_tests::test_htm_counter_concurrent ... ok test unit::utils::simd_distance_metrics_tests::test_simd_euclidean_metric ... ok test unit::utils::simd_distance_metrics_tests::test_simd_manhattan_metric ... ok    ≡ƒôû Querying from B-tree index...    ≡ƒöó Counting (O(1))...    Γ£à PASS: Retrieved 100 items efficiently test integration::caching_tests::test_structural_index_query_performance ... ok    Γ£à PASS: 2 benchmark results collected test unit::lock_free::benchmark_tests::test_benchmark_hot_vector_index ... ok Γ£à PROOF: TTL expiration triggered refetch from COLD    TTL expirations: 1    Total COLD hits: 2 test integration::warm_cache_validation::test_ttl_expiration_refetches ... ok  failures:  failures:     unit::advanced::persistence_tests::test_enhanced_vector_index     unit::advanced::persistence_tests::test_persistent_segment_index     unit::advanced::persistence_tests::test_persistent_vector_index     unit::advanced::segment_tests::test_segment_add_remove_vector     unit::advanced::segment_tests::test_segment_based_vector_index     unit::advanced::segment_tests::test_segment_manager     unit::lock_free::btree_tests::test_lock_free_btree_concurrent     unit::utils::adaptive_concurrency_tests::test_adaptive_concurrency_controller  test result: FAILED. 94 passed; 8 failed; 2 ignored; 0 measured; 0 filtered out; finished in 2.16s  error: test failed, to rerun pass `-p indexing --test mod` error: 1 target failed:     `-p indexing --test mod`
```
