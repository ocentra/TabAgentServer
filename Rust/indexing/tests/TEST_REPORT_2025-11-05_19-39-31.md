# Indexing Crate Test Report
**Generated**: 2025-11-05 19:39:34
**Mode**: 
**Total Tests**: 104
**Passed**: 1
**Failed**: 2

## Test Output
```
warning: unexpected `cfg` condition value: `std`    --> indexing\src\visit\mod.rs:451:7     | 451 | #[cfg(feature = "std")]     |       ^^^^^^^^^^^^^^^     |     = note: expected values for `feature` are: `simd`     = help: consider adding `std` as a feature in `Cargo.toml`     = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration     = note: `#[warn(unexpected_cfgs)]` on by default System.Management.Automation.RemoteException warning: unused variable: `key`    --> indexing\src\lock_free\lock_free_skiplist.rs:121:26     | 121 |     pub fn insert(&self, key: K, value: V) -> DbResult<Option<V>> {     |                          ^^^ help: if this is intentional, prefix it with an underscore: `_key`     |     = note: `#[warn(unused_variables)]` on by default System.Management.Automation.RemoteException warning: unused variable: `value`    --> indexing\src\lock_free\lock_free_skiplist.rs:121:34     | 121 |     pub fn insert(&self, key: K, value: V) -> DbResult<Option<V>> {     |                                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_value` System.Management.Automation.RemoteException warning: unused variable: `key`    --> indexing\src\lock_free\lock_free_skiplist.rs:127:23     | 127 |     pub fn get(&self, key: &K) -> DbResult<Option<V>> {     |                       ^^^ help: if this is intentional, prefix it with an underscore: `_key` System.Management.Automation.RemoteException warning: unused variable: `key`    --> indexing\src\lock_free\lock_free_skiplist.rs:135:26     | 135 |     pub fn remove(&self, key: &K) -> DbResult<Option<V>> {     |                          ^^^ help: if this is intentional, prefix it with an underscore: `_key` System.Management.Automation.RemoteException warning: unused variable: `thread_id`    --> indexing\src\lock_free\lock_free_benchmark.rs:157:13     | 157 |         for thread_id in 0..NUM_THREADS {     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_thread_id` System.Management.Automation.RemoteException warning: unused variable: `thread_id`    --> indexing\src\lock_free\lock_free_benchmark.rs:194:13     | 194 |         for thread_id in 0..NUM_THREADS {     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_thread_id` System.Management.Automation.RemoteException warning: unused variable: `edge_id`    --> indexing\src\advanced\optimized_graph.rs:475:30     | 475 |     fn edge_endpoints(&self, edge_id: Self::EdgeId) -> Option<(Self::NodeId, Self::NodeId)> {     |                              ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_edge_id` System.Management.Automation.RemoteException warning: unused variable: `node_id`    --> indexing\src\advanced\optimized_graph.rs:504:21     | 504 |     fn edges(&self, node_id: Self::NodeId) -> DbResult<Vec<(Self::EdgeId, Self::NodeId, Self::NodeId)>> {     |                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_node_id` System.Management.Automation.RemoteException warning: unused variable: `filter`    --> indexing\src\advanced\segment.rs:167:9     | 167 |         filter: Option<&crate::payload_index::PayloadFilter>,     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_filter` System.Management.Automation.RemoteException warning: unused variable: `lat`    --> indexing\src\advanced\payload_index.rs:491:51     | 491 |                     PayloadFieldValue::GeoPoint { lat, lon } => {     |                                                   ^^^ help: try ignoring the field: `lat: _` System.Management.Automation.RemoteException warning: unused variable: `lon`    --> indexing\src\advanced\payload_index.rs:491:56     | 491 |                     PayloadFieldValue::GeoPoint { lat, lon } => {     |                                                        ^^^ help: try ignoring the field: `lon: _` System.Management.Automation.RemoteException warning: unused variable: `end`    --> indexing\src\advanced\vector_storage.rs:236:13     | 236 |         let end = start + self.dimension * 4;     |             ^^^ help: if this is intentional, prefix it with an underscore: `_end` System.Management.Automation.RemoteException warning: unused variable: `offset`    --> indexing\src\advanced\vector_storage.rs:272:22     | 272 |         if let Some(&offset) = self.id_to_offset.get(id) {     |                      ^^^^^^ help: if this is intentional, prefix it with an underscore: `_offset` System.Management.Automation.RemoteException warning: unused variable: `id`    --> indexing\src\advanced\vector_storage.rs:281:34     | 281 |     fn get_vector_mut(&mut self, id: &EmbeddingId) -> DbResult<Option<&mut Vec<f32>>> {     |                                  ^^ help: if this is intentional, prefix it with an underscore: `_id` System.Management.Automation.RemoteException warning: unused variable: `chunk_id`    --> indexing\src\advanced\vector_storage.rs:487:22     | 487 |         if let Some((chunk_id, index_in_chunk)) = self.id_to_location.remove(id) {     |                      ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_chunk_id` System.Management.Automation.RemoteException warning: unused variable: `index_in_chunk`    --> indexing\src\advanced\vector_storage.rs:487:32     | 487 |         if let Some((chunk_id, index_in_chunk)) = self.id_to_location.remove(id) {     |                                ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_index_in_chunk` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:263:40     | 263 |     pub fn must_match_string(mut self, field: &str, value: &str) -> Self {     |                                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:271:41     | 271 |     pub fn must_match_integer(mut self, field: &str, value: i64) -> Self {     |                                         ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:279:41     | 279 |     pub fn must_match_boolean(mut self, field: &str, value: bool) -> Self {     |                                         ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:287:33     | 287 |     pub fn must_range(mut self, field: &str, from: Option<f64>, to: Option<f64>) -> Self {     |                                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:295:42     | 295 |     pub fn should_match_string(mut self, field: &str, value: &str) -> Self {     |                                          ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `field`    --> indexing\src\utils\builders.rs:303:44     | 303 |     pub fn must_not_match_string(mut self, field: &str, value: &str) -> Self {     |                                            ^^^^^ help: if this is intentional, prefix it with an underscore: `_field` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:341:19     | 341 |     fn bfs(&self, start: Self::NodeId) -> DbResult<Bfs<Self>>     |                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:349:27     | 349 |     fn bfs_collect(&self, start: Self::NodeId) -> DbResult<Vec<Self::NodeId>> {     |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:362:19     | 362 |     fn dfs(&self, start: Self::NodeId) -> DbResult<Dfs<Self>>     |                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:370:27     | 370 |     fn dfs_collect(&self, start: Self::NodeId) -> DbResult<Vec<Self::NodeId>> {     |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:375:30     | 375 |     fn dfs_post_order(&self, start: Self::NodeId) -> DbResult<DfsPostOrder<Self>>     |                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `start`    --> indexing\src\utils\iterators.rs:383:38     | 383 |     fn dfs_post_order_collect(&self, start: Self::NodeId) -> DbResult<Vec<Self::NodeId>> {     |                                      ^^^^^ help: if this is intentional, prefix it with an underscore: `_start` System.Management.Automation.RemoteException warning: unused variable: `hot_graph`     --> indexing\src\lib.rs:1822:21      | 1822 |         if let Some(hot_graph) = &self.hot_graph {      |                     ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hot_graph` System.Management.Automation.RemoteException warning: unused variable: `hot_graph`     --> indexing\src\lib.rs:1842:21      | 1842 |         if let Some(hot_graph) = &self.hot_graph {      |                     ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hot_graph` System.Management.Automation.RemoteException warning: field `persist_path` is never read   --> indexing\src\core\vector.rs:92:5    | 72 | pub struct VectorIndex {    |            ----------- field in this struct ... 92 |     persist_path: PathBuf,    |     ^^^^^^^^^^^^    |    = note: `#[warn(dead_code)]` on by default System.Management.Automation.RemoteException warning: field `last_access` is never read  --> indexing\src\lock_free\lock_free_common.rs:8:5   | 6 | pub struct LockFreeAccessTracker {   |            --------------------- field in this struct 7 |     access_count: AtomicUsize, 8 |     last_access: AtomicUsize,   |     ^^^^^^^^^^^   |   = note: `LockFreeAccessTracker` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis System.Management.Automation.RemoteException warning: fields `path_cache` and `centrality_cache` are never read   --> indexing\src\lock_free\lock_free_hot_graph.rs:78:5    | 58 | pub struct LockFreeHotGraphIndex {    |            --------------------- fields in this struct ... 78 |     path_cache: Arc<DashMap<(String, String), Option<Vec<String>>>>,    |     ^^^^^^^^^^ ... 81 |     centrality_cache: Arc<DashMap<String, f32>>,    |     ^^^^^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: field `mode` is never read    --> indexing\src\lock_free\lock_free_btree.rs:531:5     | 524 | pub struct LockFreeBTree<K, V>      |            ------------- field in this struct ... 531 |     mode: IndexMode,     |     ^^^^ System.Management.Automation.RemoteException warning: constant `PROBABILITY` is never used   --> indexing\src\lock_free\lock_free_skiplist.rs:16:7    | 16 | const PROBABILITY: f64 = 0.5;    |       ^^^^^^^^^^^ System.Management.Automation.RemoteException warning: fields `key`, `value`, `forward`, `level`, and `ref_count` are never read   --> indexing\src\lock_free\lock_free_skiplist.rs:21:5    | 19 | struct SkipListNode<K, V> {    |        ------------ fields in this struct 20 |     /// The key 21 |     key: K,    |     ^^^ ... 24 |     value: V,    |     ^^^^^ ... 27 |     forward: Vec<Atomic<SkipListNode<K, V>>>,    |     ^^^^^^^ ... 30 |     level: usize,    |     ^^^^^ ... 33 |     ref_count: AtomicU32,    |     ^^^^^^^^^ System.Management.Automation.RemoteException warning: methods `acquire` and `release` are never used   --> indexing\src\lock_free\lock_free_skiplist.rs:58:8    | 36 | / impl<K, V> SkipListNode<K, V> 37 | | where 38 | |     K: Ord + Clone, 39 | |     V: Clone,    | |_____________- methods in this implementation ... 58 |       fn acquire(&self) {    |          ^^^^^^^ ... 63 |       fn release(&self) -> bool {    |          ^^^^^^^ System.Management.Automation.RemoteException warning: field `max_level` is never read   --> indexing\src\lock_free\lock_free_skiplist.rs:77:5    | 72 | pub struct LockFreeSkipList<K, V> {    |            ---------------- field in this struct ... 77 |     max_level: AtomicUsize,    |     ^^^^^^^^^ System.Management.Automation.RemoteException warning: method `random_level` is never used    --> indexing\src\lock_free\lock_free_skiplist.rs:104:8     |  83 | / impl<K, V> LockFreeSkipList<K, V>  84 | | where  85 | |     K: Ord + Clone,  86 | |     V: Clone,     | |_____________- method in this implementation ... 104 |       fn random_level(&self) -> usize {     |          ^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: methods `acquire_vec_string` and `release_vec_string` are never used     --> indexing\src\advanced\hybrid.rs:1408:8      |  451 | impl HotGraphIndex {      | ------------------ methods in this implementation ... 1408 |     fn acquire_vec_string(&mut self) -> Vec<String> {      |        ^^^^^^^^^^^^^^^^^^ ... 1413 |     fn release_vec_string(&mut self, mut vec: Vec<String>) {      |        ^^^^^^^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: fields `path_cache` and `centrality_cache` are never read    --> indexing\src\advanced\optimized_graph.rs:125:5     |  96 | pub struct OptimizedGraphIndex {     |            ------------------- fields in this struct ... 125 |     path_cache: HashMap<(NodeIndex, NodeIndex), Option<Vec<NodeIndex>>>,     |     ^^^^^^^^^^ ... 128 |     centrality_cache: HashMap<NodeIndex, f32>,     |     ^^^^^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: field `path` is never read   --> indexing\src\advanced\segment.rs:32:5    | 27 | pub struct Segment {    |            ------- field in this struct ... 32 |     path: PathBuf,    |     ^^^^ System.Management.Automation.RemoteException warning: field `distance_metric` is never read    --> indexing\src\advanced\segment.rs:446:5     | 441 | pub struct SegmentBasedVectorIndex {     |            ----------------------- field in this struct ... 446 |     distance_metric: Box<dyn DistanceMetric>,     |     ^^^^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: field `file_path` is never read    --> indexing\src\advanced\vector_storage.rs:114:5     | 112 | pub struct MmapVectorStorage {     |            ----------------- field in this struct 113 |     /// Path to the storage file 114 |     file_path: PathBuf,     |     ^^^^^^^^^ System.Management.Automation.RemoteException warning: method `load_chunk` is never used    --> indexing\src\advanced\vector_storage.rs:416:8     | 368 | impl ChunkedVectorStorage {     | ------------------------- method in this implementation ... 416 |     fn load_chunk(&self, chunk_id: usize) -> DbResult<Chunk> {     |        ^^^^^^^^^^ System.Management.Automation.RemoteException warning: field `distance_metric` is never read    --> indexing\src\advanced\persistence.rs:356:5     | 351 | pub struct EnhancedVectorIndex {     |            ------------------- field in this struct ... 356 |     distance_metric: Box<dyn DistanceMetric>,     |     ^^^^^^^^^^^^^^^ System.Management.Automation.RemoteException warning: field `graph` is never read    --> indexing\src\utils\iterators.rs:220:5     | 218 | pub struct EdgeIterator<G: GraphBase> {     |            ------------ field in this struct 219 |     /// The graph being traversed 220 |     graph: G,     |     ^^^^^ System.Management.Automation.RemoteException warning: constant `Outgoing` should have an upper case name    --> indexing\src\algorithms\graph_traits.rs:139:11     | 139 | pub const Outgoing: Direction = Direction::Outgoing;     |           ^^^^^^^^ help: convert the identifier to upper case: `OUTGOING`     |     = note: `#[warn(non_upper_case_globals)]` on by default System.Management.Automation.RemoteException warning: constant `Incoming` should have an upper case name    --> indexing\src\algorithms\graph_traits.rs:142:11     | 142 | pub const Incoming: Direction = Direction::Incoming;     |           ^^^^^^^^ help: convert the identifier to upper case: `INCOMING` System.Management.Automation.RemoteException warning: `indexing` (lib) generated 50 warnings     Finished `test` profile [unoptimized + debuginfo] target(s) in 0.56s      Running tests\mod.rs (target\debug\deps\mod-d87d95079f28f61f.exe)  running 104 tests  ΓÜí TEST: Structural index query performance (100 items)  ≡ƒò╕∩╕Å  TEST: Add edges and retrieve outgoing edges with zero-copy NEGATIVE TEST: Attempting to open same database twice (should fail)   First open...  ≡ƒò╕∩╕Å  TEST: Add edges and retrieve incoming edges with zero-copy  ≡ƒÆ¼ TEST: Index Chat node across all indexes ΓÖ╗∩╕Å  Reusing existing mock vectors database  ≡ƒÆ╛ TEST: Graph index caching consistency  ≡ƒöä TEST: Verify both outgoing AND incoming indexes updated atomically  ≡ƒöó TEST: Zero-copy edge counting (O(1) performance)  ≡ƒùæ∩╕Å  TEST: Remove edge and verify it's gone from both directions  ≡ƒöì TEST: Vector search caching consistency  ≡ƒöù TEST: Index edge in graph index  ≡ƒÄ¿ TEST: Index embedding in vector index  ≡ƒùæ∩╕Å  TEST: Remove vector from HNSW index  ≡ƒùé∩╕Å  TEST: Add property indexes and retrieve with zero-copy (NEW ARCHITECTURE)  ≡ƒöì TEST: Add 3D vectors and search with HNSW  ≡ƒôè TEST: Vector metadata (timestamp, dimension)  ≡ƒîÉ TEST: High-dimensional vectors (384D like real embeddings)  Γ£ë∩╕Å  TEST: Index Message node across all indexes    ≡ƒô¥ Adding 3 vectors (3D)...    ≡ƒô¥ Adding vector v1...    ≡ƒùæ∩╕Å  Removing v1...    ≡ƒùæ∩╕Å  Removing again (should fail)...    Γ£à PASS: Vector removed successfully    ≡ƒöÄ First search...    ≡ƒöÄ Second search (consistency check)...    Γ£à PASS: Search results consistent    ≡ƒô¥ Adding 3 vectors (3D)...    ≡ƒô¥ Adding vector with metadata...    ≡ƒôû Reading metadata...    ≡ƒô¥ Creating 384-dimensional vectors...    ≡ƒöÄ Searching for nearest neighbors...    Γ£à PASS: Metadata stored (timestamp=1762389572241, dim=3)    ≡ƒô¥ Adding 3 high-dimensional vectors...    Γ£à PASS: Found 2 nearest neighbors    ≡ƒöÄ Searching in 384D space...    Γ£à PASS: HNSW works with 384-dimensional vectors   Second open (same file, should fail with locking error)... ΓÖ╗∩╕Å  Reusing existing mock vectors database test integration::vector_tests::test_remove ... ok test integration::vector_tests::test_metadata ... ok test integration::vector_tests::test_add_and_search ... ok test integration::caching_tests::test_vector_index_search_caching ... ok   TEST PASSED: Got expected locking error: Invalid operation: mdbx_env_open failed: -30778 NEGATIVE TEST COMPLETE: File locking protection prevents duplicate opens test integration::vector_tests::test_realistic_dimensions ... ok test fixtures::tests::test_mock_vectors_db_reusable ... ok  ≡ƒöÑ TEST: Hot graph index basic operations    ≡ƒô¥ Adding 2 nodes...  ≡ƒôè TEST: Access pattern tracking for tier management    ≡ƒô¥ Adding node...  ≡ƒöÑ TEST: Hot vector index basic operations    ≡ƒô¥ Adding 3 vectors to hot tier...    ≡ƒôû Checking initial temperature...    ≡ƒô¥ Adding vector to hot tier...    ≡ƒô¥ Adding edge...    ≡ƒôû Checking neighbors...    ≡ƒöÄ Searching hot tier...    Γ£à PASS: Both graph and vector track temperature correctly    ≡ƒùæ∩╕Å  Removing edge...    Γ£à PASS: Hot graph add/remove works    Γ£à PASS: Hot vector search works (similarity=1.00) test unit::advanced::hybrid_tests::test_access_tracking ... ok    ≡ƒô¥ Adding 2 edges from chat_1...    ≡ƒôû Reading outgoing edges (ZERO-COPY)...    Γ£à PASS: Retrieved 2 edges with zero-copy    ≡ƒô¥ Adding 2 edges to msg_1...    ≡ƒô¥ Adding 100 messages to chat_123...    ≡ƒô¥ Adding edge: chat_1 -> msg_1 test unit::advanced::hybrid_tests::test_hot_graph_index_basic_operations ... ok    ≡ƒô¥ Adding 2 edges...    ≡ƒôû Checking outgoing from chat_1...    ≡ƒôû Checking incoming to msg_1...    Γ£à PASS: Bidirectional index works atomically    ≡ƒô¥ Indexing edge...    ≡ƒôû Reading incoming edges (ZERO-COPY)...    Γ£à PASS: Retrieved 2 incoming edges    ≡ƒô¥ Indexing chat node...    ≡ƒôû First read from MDBX...    ≡ƒôû Second read (tests consistency)...    Γ£à PASS: Consistent reads from cache test unit::advanced::hybrid_tests::test_hot_vector_index_basic_operations ... ok  ≡ƒöó TEST: Quantized vector compression    ≡ƒô¥ Quantizing vector...  ≡ƒôÉ TEST: Quantized vector cosine similarity    ≡ƒöÄ Computing similarities...    ≡ƒôû Querying outgoing edges (ZERO-COPY)...    ≡ƒôû Reconstructing vector...  ≡ƒù║∩╕Å  TEST: Memory-map multiple vectors    Γ£à PASS: Similar=0.99, Orthogonal=0.00    Γ£à PASS: Edge indexed in graph    Γ£à PASS: Quantization loss < 1%    ≡ƒôû Querying by node_type (ZERO-COPY)...    ≡ƒôû Querying by topic (ZERO-COPY)...    Γ£à PASS: Chat indexed across all properties test unit::advanced::hybrid_tests::test_quantized_vector_cosine_similarity ... ok    ≡ƒô¥ Adding 3 messages to 2 chats... test unit::advanced::hybrid_tests::test_quantized_vector_basic ... ok  ≡ƒÆ╛ TEST: Memory-map persistence across instances  ≡ƒù║∩╕Å  TEST: Memory-mapped vector write/read    ≡ƒôû Reading chat_123 messages (ZERO-COPY)...    ≡ƒôû Reading chat_456 messages (ZERO-COPY)...    Γ£à PASS: Retrieved 2 + 1 nodes with zero-copy    ≡ƒô¥ Indexing message node...    ≡ƒôû Querying by chat_id (ZERO-COPY)... test integration::graph_tests::test_add_and_get_outgoing_zero_copy ...    ≡ƒô¥ Adding 2 edges...    Γ£à PASS: Message indexed and retrieved ok  ≡ƒöÇ TEST: Hybrid vector index with payload filtering test fixtures::tests::test_create_temp_db ... ok  ≡ƒôª TEST: Create payload with mixed field types    ≡ƒô¥ Adding edge...    ≡ƒô¥ Adding string, integer, boolean fields... test integration::caching_tests::test_graph_index_caching_behavior ... ok    Γ£à PASS: Payload created with 3 fields  ≡ƒöì TEST: Filter vectors by payload metadata    ≡ƒô¥ Adding 2 vectors with payloads... test unit::advanced::payload_index_tests::test_payload_creation ... ok    ≡ƒöó Counting edges (ZERO-COPY O(1))...    Γ£à PASS: Counted 2 outgoing, 1 incoming    ≡ƒöì Filtering by category=A...  ≡ƒîƒ TEST: Enhanced vector index with persistence    Γ£à PASS: Filtered 1 vectors by payload    ≡ƒùæ∩╕Å  Removing edge...    Γ£à PASS: Edge removed from both directions    ≡ƒô¥ Indexing 384D embedding... test unit::advanced::payload_index_tests::test_payload_index ... ok  ≡ƒÆ╛ TEST: Persistent segment index save/load    ≡ƒô¥ Creating mmap storage (4D)...    ≡ƒöÄ Searching for similar vectors...    Γ£ì∩╕Å  Writing vector (first mmap instance)...    Γ£à PASS: Found 1 similar vectors    ≡ƒô¥ Creating mmap storage (3D)... test integration::index_manager_tests::test_index_chat_node_zero_copy ... ok test integration::graph_tests::test_add_and_get_incoming_zero_copy ... ok test integration::graph_tests::test_bidirectional_index ...  ≡ƒÆ╛ TEST: Persistent vector index save/load ok  ≡ƒôè TEST: Add and remove vectors from segment test integration::index_manager_tests::test_index_edge_zero_copy ... ok  ≡ƒöì TEST: Segment-based vector index search Γ£à PROOF: Cache hit ratio exceeds 80% target    Hit ratio: 89.00%    Warm hits: 89    Cold hits: 11  ≡ƒôè TEST: Create vector segment test integration::structural_tests::test_nonexistent_property ... ok    ≡ƒô¥ Creating hybrid index...  ≡ƒôÜ TEST: Segment manager auto-creates segments    Γ£ì∩╕Å  Writing 3 vectors...    Γ£ì∩╕Å  Writing vector to mmap...    ≡ƒô¥ Creating enhanced vector index with 3D vectors... test integration::structural_tests::test_remove ... ok test integration::structural_tests::test_duplicate_add ... ok Γ£à PROOF: 1 allocation saved 99 MDBX transactions    Cold hits (MDBX): 1    Warm hits (cache): 99  ≡ƒôª TEST: Chunked vector storage  ≡ƒùä∩╕Å  TEST: In-memory vector storage    ≡ƒô¥ Adding vector...    ≡ƒôû Retrieving vector...    ≡ƒùæ∩╕Å  Removing vector...    Γ£à PASS: In-memory storage works    ≡ƒÆ╛ Dropping storage (should flush to disk)...    ≡ƒôû Reading vector from mmap (ZERO-COPY)...    Γ£à PASS: Vector written and read via mmap test unit::advanced::vector_storage_tests::test_in_memory_storage ... ok    ≡ƒôû Reading vector (new mmap instance)...  ≡ƒù║∩╕Å  TEST: Memory-mapped vector storage    ≡ƒô¥ Creating persistent segment index with 3D vectors...    ≡ƒôû Reading all 3 vectors (ZERO-COPY)...    Γ£à PASS: 3 vectors stored at different offsets test integration::structural_tests::test_add_and_get_zero_copy ... ok  ΓÜí TEST: Benchmark hot vector index performance    ≡ƒöº Running benchmark... test integration::structural_tests::test_to_owned_when_needed ... ok test integration::structural_tests::test_count_zero_copy ... ok test unit::lock_free::benchmark_tests::test_benchmark_hot_vector_index_search ... ignored, Long-running benchmark test - run with --ignored test unit::lock_free::benchmark_tests::test_benchmark_mixed_workload ... ignored, Long-running benchmark test - run with --ignored  ΓÜí TEST: Benchmark result calculations    Γ£à PASS: 20000 ops/sec calculated correctly  ≡ƒî│ TEST: Adaptive B-tree basic operations    ≡ƒô¥ Insert 1=one...    Γ£à PASS: Data persists across mmap instances    ≡ƒô¥ Insert 2=two...    ≡ƒô¥ Creating segment-based index with 3D vectors...    ≡ƒô¥ Insert 3=three... test unit::lock_free::benchmark_tests::test_benchmark_result_creation ...    Γ£à PASS: Adaptive B-tree works correctly ok    ≡ƒô¥ Creating segment with 3D vectors... test integration::warm_cache_validation::test_hot_node_cache_hit_ratio ... ok  ≡ƒî│ TEST: Adaptive B-tree concurrent inserts (PRODUCTION FIX)    ≡ƒô¥ Creating persistent index with 3D vectors...    ≡ƒô¥ Creating manager with max 2 vectors per segment and 3D vectors...    ≡ƒô¥ Creating segment with capacity 1000... test unit::lock_free::btree_tests::test_lock_free_btree_basic ... ok    ≡ƒº╡ Spawning 100 threads...  ≡ƒôè TEST: Lock-free access tracker  ≡ƒôê TEST: Lock-free statistics tracking    ≡ƒô¥ Recording stats...    Γ£à PASS: Stats tracked (queries=1, vectors=1)    ≡ƒô¥ Recording access...    Γ£à PASS: Access tracked (count=1)    ≡ƒô¥ Adding 2 vectors...    ≡ƒô¥ Adding 2 vectors... test integration::graph_tests::test_count_zero_copy ... ok    ≡ƒô¥ Adding vector with payload... test integration::index_manager_tests::test_index_message_node_zero_copy ... ok    ≡ƒô¥ Creating chunked storage (10 vectors/chunk)...    ≡ƒô¥ Creating mmap storage...  ≡ƒò╕∩╕Å  TEST: Lock-free hot graph index basic operations    ≡ƒöÄ Searching with filter...    ≡ƒô¥ Adding node...    Γ£à PASS: Hybrid index works with payloads  ≡ƒò╕∩╕Å  TEST: Lock-free hot graph index concurrent adds test unit::lock_free::hash_map_tests::test_lock_free_stats ... ok    ≡ƒº╡ Spawning 10 threads...    ≡ƒô¥ Adding edge... test unit::lock_free::hash_map_tests::test_lock_free_access_tracker ... ok ≡ƒöÑ TEST: Lock-free hot vector index basic operations    ≡ƒôû Getting neighbors...     Γ£à PASS: Graph has 2 nodes    ≡ƒô¥ Adding vector...    ≡ƒùæ∩╕Å  Removing vector...    ≡ƒô¥ Adding vector...    ≡ƒùæ∩╕Å  Removing vector...    Γ£à PASS: Add/remove works test integration::graph_tests::test_remove_edge ... ok    ≡ƒô¥ Adding 2 vectors...    Γ£à PASS: Chunked storage works    ≡ƒÆ╛ Saving index to disk...    Γ£à PASS: Segment created (id=test_segment, len=0)    ΓÅ│ Waiting for threads...    ≡ƒô¥ Adding vector...    ≡ƒô¥ Adding vector...  ≡ƒöÑ TEST: Lock-free hot vector index concurrent adds    ≡ƒùæ∩╕Å  Removing vector...    ≡ƒº╡ Spawning 10 threads...    Γ£à PASS: Mmap storage works    ≡ƒô¥ Adding 3 vectors (should create 2 segments)...    ≡ƒùæ∩╕Å  Removing vector...  ΓÜí TEST: Adaptive concurrency controller (mode switching)    Γ£à PASS: Vector added and removed    ≡ƒöì Initial mode: Traditional    ≡ƒôè Simulating high load (15k ops)...    ≡ƒöä Mode after switch: LockFree    Γ£à PASS: Switched from Traditional -> LockFree under high load    ≡ƒô¥ Adding 2 vectors...    Γ£à PASS: Index saved to C:\Users\sujan\AppData\Local\Temp\.tmpfGlmCP\test_index.bin    ≡ƒÆ╛ Saving segments to disk... test integration::warm_cache_validation::test_warm_cache_saves_cold_transactions ... ok   Γ£à PASS: Segments saved to C:\Users\sujan\AppData\Local\Temp\.tmpRKJB3g\segments  test unit::advanced::memory_mapping_tests::test_mmap_vector_storage_write_and_read ... ok    ΓÅ│ Waiting for threads... test integration::index_manager_tests::test_index_embedding ... ok    ≡ƒöÄ Searching... test unit::lock_free::hot_graph_tests::test_lock_free_hot_graph_index_basic ... ok    ≡ƒôè Checking statistics...    Γ£à PASS: Found 2 vectors, stats show 2 total test unit::advanced::memory_mapping_tests::test_mmap_multiple_vectors ... ok test unit::lock_free::hot_vector_tests::test_lock_free_hot_vector_index_basic ... ok test unit::advanced::memory_mapping_tests::test_mmap_persistence ... ok  ≡ƒÅù∩╕Å  TEST: EnhancedIndexBuilder (advanced features)    ≡ƒô¥ Building enhanced index with auto-optimize...  ≡ƒò╕∩╕Å  TEST: Adaptive graph index (dynamic mode)    ≡ƒôè Checking statistics...    Γ£à PASS: 3 vectors across 2 segments    ≡ƒöì Initial mode: Traditional    ≡ƒô¥ Adding node + edge... test unit::advanced::vector_storage_tests::test_chunked_storage ... ok    Γ£à PASS: Adaptive graph index works test unit::advanced::payload_index_tests::test_hybrid_vector_index ... ok    Γ£à PASS: EnhancedIndexBuilder works  ≡ƒöì TEST: Adaptive vector index (dynamic mode) test unit::utils::adaptive_concurrency_tests::test_adaptive_concurrency_controller ... ok    ≡ƒöì Initial mode: Traditional    ≡ƒô¥ Adding vector...    ≡ƒöì Searching...    Γ£à PASS: Adaptive vector index works (len=1)  ≡ƒôª TEST: Combined batch processor (vectors + graph)    ΓÅ│ Waiting for threads...  ≡ƒôª TEST: Graph batch processor (bulk nodes/edges)    ≡ƒô¥ Batch processing vectors + graph ops...    Γ£à PASS: Combined batch works (2 vectors, 2 nodes)    ≡ƒô¥ Batch adding 2 nodes...    ≡ƒô¥ Batch adding 2 edges...    ≡ƒùæ∩╕Å  Batch removing 2 edges...    ≡ƒùæ∩╕Å  Batch removing 2 nodes...  ≡ƒÅù∩╕Å  TEST: GraphIndexBuilder (graph configuration)    ≡ƒô¥ Building graph index builder (hybrid mode)...    Γ£à PASS: GraphIndexBuilder construction works    Γ£à PASS: Batch graph operations work (2 nodes, 2 edges)  ≡ƒÅù∩╕Å  TEST: PayloadBuilder (multi-field metadata)    ≡ƒô¥ Building payload with 3 fields...    Γ£à PASS: PayloadBuilder works (3 fields)  ≡ƒÅù∩╕Å  TEST: PayloadFilterBuilder (must/should/must_not)    ≡ƒô¥ Building filter (2 must, 1 should, 1 must_not)...    Γ£à PASS: PayloadFilterBuilder works  ≡ƒÅù∩╕Å  TEST: SearchQueryBuilder (query configuration)    ≡ƒô¥ Building search query (limit=5, payload=true)...    Γ£à PASS: SearchQueryBuilder works    Γ£à PASS: 10 concurrent node adds successful  ≡ƒôª TEST: Vector batch processor (bulk add/remove)    ≡ƒô¥ Batch adding 2 vectors...    ≡ƒùæ∩╕Å  Batch removing 2 vectors...    Γ£à PASS: Batch add/remove works (2 vectors) test unit::advanced::vector_storage_tests::test_mmap_storage ... ok test unit::advanced::segment_tests::test_segment_creation ... ok  ≡ƒÅù∩╕Å  TEST: SegmentIndexBuilder (multi-segment index) test unit::advanced::segment_tests::test_segment_add_remove_vector ... ok  ≡ƒÅù∩╕Å  TEST: VectorIndexBuilder (fluent construction)    Γ£à PASS: 10 concurrent vector adds successful test unit::advanced::persistence_tests::test_persistent_vector_index ... ok    ≡ƒô¥ Building with segment params (5k/segment)...  ≡ƒôè TEST: Cache statistics tracking    ≡ƒô¥ Performing cache operations...    ≡ƒôè Checking statistics...    Γ£à PASS: Stats tracked (hits=2, misses=1, ratio=67%) test unit::advanced::persistence_tests::test_persistent_segment_index ... ok test unit::utils::adaptive_concurrency_tests::test_adaptive_graph_index ... ok    ≡ƒô¥ Building with custom params (M=32, efC=100)...  ≡ƒò╕∩╕Å  TEST: Graph traversal result caching    ≡ƒô¥ Caching BFS results...    ≡ƒô¥ Caching shortest path results...    Γ£à PASS: Graph traversal cache stores BFS + paths  ≡ƒÆ╛ TEST: LRU cache eviction policy    ≡ƒô¥ Adding key1, key2 (capacity=2)...    ≡ƒô¥ Adding key3 (should evict LRU)...    ≡ƒùæ∩╕Å  Removing key2...    Γ£à PASS: LRU eviction works correctly test unit::utils::adaptive_concurrency_tests::test_adaptive_vector_index ... ok  ≡ƒÆ╛ TEST: Multi-level cache (primary + secondary)    ≡ƒô¥ Adding 3 values...    ≡ƒô¥ Adding key4, key5 (triggers eviction)... test unit::advanced::segment_tests::test_segment_based_vector_index ... ok  ≡ƒöì TEST: Vector search result caching    ≡ƒôû Verifying all inserts (including key 56 that was missing before)...    ≡ƒôè Checking stats...    Γ£à PASS: VectorIndexBuilder works    Γ£à PASS: Multi-level cache works (4 accesses)    ≡ƒô¥ Caching search results... test unit::utils::batch_tests::test_combined_batch_processor ... ok  ΓÜÖ∩╕Å  TEST: Warm graph cache configuration defaults    ≡ƒô¥ Caching metadata...    Γ£à PASS: ALL 100 concurrent inserts successful (no missing keys!)    Γ£à PASS: Vector search cache stores results + metadata shard 0: ShardStats { reads: 4, writes: 4 } shard 1: ShardStats { reads: 9, writes: 9 } shard 2: ShardStats { reads: 3, writes: 3 } shard 3: ShardStats { reads: 7, writes: 7 }  ΓÜÖ∩╕Å  TEST: Warm vector cache configuration defaults    Γ£à PASS: Default config (vectors=10000, searches=1000, TTL=3600s) test unit::utils::builders_tests::test_enhanced_index_builder ... ok    Γ£à PASS: Default config (edges=5000, nodes=10000, TTL=1800s)    Γ£à PASS: SegmentIndexBuilder works shard 4: ShardStats { reads: 8, writes: 8 } shard 5: ShardStats { reads: 7, writes: 7 } shard 6: ShardStats { reads: 6, writes: 6 } shard 7: ShardStats { reads: 8, writes: 8 } test unit::utils::builders_tests::test_graph_index_builder ... ok shard 8: ShardStats { reads: 6, writes: 6 } shard 9: ShardStats { reads: 9, writes: 9 } shard 10: ShardStats { reads: 5, writes: 5 } shard 11: ShardStats { reads: 8, writes: 8 } shard 12: ShardStats { reads: 6, writes: 6 } shard 13: ShardStats { reads: 4, writes: 4 } shard 14: ShardStats { reads: 2, writes: 2 } shard 15: ShardStats { reads: 8, writes: 8 } test unit::utils::batch_tests::test_graph_batch_processor ... ok  ≡ƒôÉ TEST: Cosine similarity metric    ≡ƒöì Testing identical vectors...  ≡ƒöü TEST: Binary conversion helpers    ≡ƒöì Testing threshold binarization...    Γ£à PASS: Binary conversion works (threshold=0.5)  ΓÜí TEST: Dot product similarity metric    ≡ƒöì Testing identical vectors... test unit::advanced::segment_tests::test_segment_manager ...    ≡ƒöì Testing orthogonal vectors...    Γ£à PASS: Dot product metric works ok    ≡ƒöì Testing orthogonal vectors... global reads/writes: 100/100    ≡ƒöì Testing opposite vectors...    Γ£à PASS: Cosine metric works (identical=1.0, orthogonal=0.0, opposite=-1.0) test unit::utils::builders_tests::test_payload_builder ... ok test unit::utils::builders_tests::test_payload_filter_builder ... ok  ≡ƒöä TEST: Dynamic metric dispatch (runtime selection)    ≡ƒöì Testing cosine (dynamic)...  ≡ƒöó TEST: Hamming distance (bit differences)    ≡ƒöì Testing identical binary vectors... test unit::utils::builders_tests::test_search_query_builder ... ok    ≡ƒöì Testing completely different vectors...    ≡ƒöì Testing euclidean (dynamic)...    ≡ƒöì Testing jaccard with params (dynamic)...  ≡ƒôÅ TEST: Euclidean distance metric    ≡ƒöì Testing identical vectors (distance=0)...    ≡ƒöì Testing with custom threshold...    Γ£à PASS: Hamming metric works  ≡ƒÄ» TEST: Jaccard similarity (set overlap)    ≡ƒöì Testing identical binary vectors... test unit::lock_free::hot_graph_tests::test_lock_free_hot_graph_index_concurrent ... ok    Γ£à PASS: Dynamic dispatch works for all metrics    ≡ƒöì Testing completely different vectors...    ≡ƒöì Testing with custom threshold...    Γ£à PASS: Jaccard metric works    ≡ƒöì Testing unit distance...    ≡ƒöì Testing diagonal (ΓêÜ2)...    Γ£à PASS: Euclidean metric works test unit::utils::batch_tests::test_vector_batch_processor ... ok  ≡ƒôì TEST: Manhattan (L1) distance metric    ≡ƒöì Testing Manhattan distance...  ≡ƒôÜ TEST: Documentation examples compile    Γ£à PASS: Doc examples compile (tested in respective modules)    Γ£à PASS: Manhattan metric (L1 norm) works test unit::lock_free::hot_vector_tests::test_lock_free_hot_vector_index_concurrent ... ok test unit::utils::caching_tests::test_cache_stats ... ok test unit::utils::caching_tests::test_graph_traversal_cache ... ok  Γ¥î TEST: BatchError display formatting    Γ£à PASS: BatchError formats correctly  Γ¥î TEST: GraphIndexError display formatting test unit::utils::caching_tests::test_lru_cache ... ok Γ¥î TEST: HybridIndexError display formatting    Γ£à PASS: HybridIndexError formats correctly    ≡ƒöÄ Searching...     Γ£à PASS: GraphIndexError formats correctly    ≡ƒÆ╛ Flushing to disk...    Γ£à PASS: Enhanced index works with 2 vectors test unit::utils::caching_tests::test_multi_level_cache ... ok test unit::utils::caching_tests::test_vector_search_cache ...  Γ¥î TEST: IndexingError display formatting  Γ¥î TEST: StructuralIndexError display formatting    Γ£à PASS: StructuralIndexError formats correctly    Γ£à PASS: IndexingError formats correctly ok test unit::utils::caching_tests::test_warm_vector_cache_config ... ok  Γ¥î TEST: VectorIndexError display formatting    Γ£à PASS: VectorIndexError formats correctly test unit::utils::caching_tests::test_warm_graph_cache_config ... ok  ΓÜí TEST: HTM counter basic operations    ≡ƒöì Initial value: 0    Γ£à PASS: HTM counter increments (0 -> 2) test unit::utils::builders_tests::test_vector_index_builder ... ok test unit::utils::distance_metrics_tests::test_binary_helpers ...  ΓÜí TEST: HTM counter concurrent increments (10 threads)    ≡ƒÜÇ Spawning 10 threads... ok  ΓÜí TEST: HTM HashMap (not yet implemented)    ≡ƒöì Testing operations return errors (not implemented)...    Γ£à PASS: HTM HashMap correctly returns errors (unimplemented) test unit::utils::distance_metrics_tests::test_dot_product_metric ... ok test unit::utils::distance_metrics_tests::test_cosine_metric ... ok test unit::lock_free::btree_tests::test_lock_free_btree_concurrent ... ok    ΓÅ│ Waiting for threads to complete...  ≡ƒöü TEST: DFS iterator (placeholder)    Γ£à PASS: Module compiles (comprehensive tests in graph_tests.rs) test unit::utils::distance_metrics_tests::test_hamming_metric ... ok  ≡ƒÜÇ TEST: SIMD cosine metric (vectorized)    ≡ƒöì Testing SIMD cosine (identical + orthogonal)...    Γ£à PASS: SIMD cosine metric works test unit::utils::distance_metrics_tests::test_dynamic_metric ... ok  ≡ƒÜÇ TEST: SIMD euclidean metric (vectorized)    ≡ƒöì Testing SIMD euclidean...    Γ£à PASS: SIMD euclidean metric works test unit::utils::distance_metrics_tests::test_jaccard_metric ... ok test unit::utils::distance_metrics_tests::test_euclidean_metric ... ok  ≡ƒÜÇ TEST: SIMD dot product metric (vectorized)    ≡ƒöì Testing SIMD dot product...    Γ£à PASS: SIMD dot product metric works test unit::utils::docs_tests::test_documentation_compiles ... ok  ≡ƒöü TEST: BFS iterator (placeholder)    Γ£à PASS: Module compiles (comprehensive tests in graph_tests.rs) test unit::utils::distance_metrics_tests::test_manhattan_metric ... ok test unit::utils::builders_tests::test_segment_index_builder ... ok test unit::utils::errors_tests::test_batch_error ... ok test unit::utils::errors_tests::test_hybrid_index_error ... ok test unit::utils::errors_tests::test_graph_index_error ... ok test unit::utils::errors_tests::test_structural_index_error ... ok  ≡ƒÜÇ TEST: SIMD manhattan metric (vectorized)    ≡ƒöì Testing SIMD manhattan...    Γ£à PASS: SIMD manhattan metric works test unit::utils::errors_tests::test_indexing_error ... ok test unit::utils::errors_tests::test_vector_index_error ... ok test unit::utils::htm_tests::test_htm_counter_basic ... ok    Γ£à PASS: HTM counter correctly incremented by 10 threads (result=10) test unit::utils::htm_tests::test_htm_hash_map ... ok test unit::utils::iterators_tests::test_dfs_iterator_placeholder ... ok test unit::utils::simd_distance_metrics_tests::test_simd_cosine_metric ... ok test unit::advanced::persistence_tests::test_enhanced_vector_index ... ok test unit::utils::simd_distance_metrics_tests::test_simd_euclidean_metric ... ok test unit::utils::simd_distance_metrics_tests::test_simd_dot_product_metric ... ok test unit::utils::iterators_tests::test_bfs_iterator_placeholder ... ok test unit::utils::simd_distance_metrics_tests::test_simd_manhattan_metric ... ok test unit::utils::htm_tests::test_htm_counter_concurrent ... ok    ≡ƒôû Querying from B-tree index...    ≡ƒöó Counting (O(1))...    Γ£à PASS: Retrieved 100 items efficiently test integration::caching_tests::test_structural_index_query_performance ... ok    Γ£à PASS: 2 benchmark results collected test unit::lock_free::benchmark_tests::test_benchmark_hot_vector_index ... ok Γ£à PROOF: TTL expiration triggered refetch from COLD    TTL expirations: 1    Total COLD hits: 2 test integration::warm_cache_validation::test_ttl_expiration_refetches ... ok  test result: ok. 102 passed; 0 failed; 2 ignored; 0 measured; 0 filtered out; finished in 2.06s 
```
